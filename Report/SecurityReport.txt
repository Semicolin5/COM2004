We have implemented user authentication through a login system when the application is first loaded up.  If a correct User ID and password combination is recognised, the user is logged into the system with their respective account.  Sessions are handled by holding the current Users ID and Privilege in a ‘User Object’.  This object is queried whenever we need to determine what to display to which user.   Whenever a user logs out, the User object is cleared and set to NULL.  This prevents privilege escalation by making sure other users cannot steal other user’s credentials.
Passwords are hashed using the SHA-256 algorithm with 16 byte salts.  When saving a password, first we generate a Salt using the Secure Random object in Java.  This allows us to generate cryptographically random Salts.  Next these salts are appended to the password and then run through the SHA-256 function.  The salt and the hashed password are then stored in our database.  If a person was able to access our User table in the database, they would only be able to get the salts and hashed passwords.  Due to the nature of the SHA algorithm, it is practically impossible to reverse and retrieve the pre-hashed password.  Random salting provides protection against rainbow table attacks and prevents matching post-hash passwords.  Two users may share the same password, but will have two different salts and hashes.
Our password policy forces users to have at least  1 Uppercase letter, 1 lowercase, 1 number, 1 special character and between 8 – 16 characters.  This policy increases the complexity of our passwords and protects our users against brute force attacks.
We have protected against SQL injection attacks by using prepared statements whenever a user input is passed into a query.   As an additional measure, user inputs are sanitised using Regex pattern matching strings.  E.g. regDepartment = "[A-Z]{3}”.  This means that a department code must be 3 A-Z (Uppercase only) characters, no more no less.  In addition, we also run checks to protect against duplicate or null inputs.  If we get a input we get an input we shouldn’t handle we immediately reject it and do not try to correct it.   This prevents more complicated ‘crafted’ attacks.
